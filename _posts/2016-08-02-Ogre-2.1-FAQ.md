---
layout: post
title:  "Ogre 2.1 FAQ"
date:   2016-08-02
categories: 博客
tags: Ogre FAQ
---

* content
{:toc}

### 2.1 版是否稳定？
它是稳定的，它很少崩溃与泄露 (和其他稳定版差不多)   
虽然仍在开发中，可能需要你花上 10 到 20 分钟来调整你的代码，但是不会有重大的变化了。  
目前 Ogre 2.1 的主要问题是 WIKI 和 插件的不足而不是 Ogre 2.1 的稳定性，虽然社区用户进行了一些插件的移植工作但还无法评估它们的质量（不是说他们质量差）  

如果你还是不相信 Ogre 2.1 可以稳定的支持高质量的项目，那么可以参考下面的内容：

* [Racecraft](https://steamcommunity.com/app/346610)([Official Site](http://playracecraft.com/racecraft/))
* 社区成员 xrgo 开发中的非游戏商业 VR 项目 ( 对不起，目前还没有开放的图片)
* [Unnamed Wild West shooter](http://www.ogre3d.org/forums/viewtopic.php?f=11&t=88577)

### 有否参考手册？
有的，你在这里可以找到 [Docs/2.0/Ogre 2.0 Porting Manual DRAFT.odt](https://bitbucket.org/sinbad/ogre/src/c03d006c03f217e879cbdd6ea4cc377c4d4f7ba4/Docs/2.0/Ogre%202.0%20Porting%20Manual%20DRAFT.odt?at=v2-1&fileviewer=file-view-default)。 
我们建议使用 OpenOffice 或 LibreOffice 查看, 如果你喜欢使用 PDF 阅读器也可以导出为 PDF 进行阅读，微软 WORD 软件会出现一些排版的问题。 

### 有样例代码或例子程序吗？
有的! 你只需要在 CMake 中选中 OGRE_BUILD_SAMPLES2 (请注意，不是 OGRE_BUILD_SAMPLES 选项，这个选项最终将被移除)。   
如果这些例子无法编译，可能是你没有提供 SDL2 依赖库， 还有一些例子使用了 RapidJSON，如果你克隆了 [ogredeps](https://bitbucket.org/cabalistic/ogredeps) 你就都有了。   
注意：你必须克隆依赖项的代码仓库，下载的 ZIP 包是无法正常工作的， ZIP 包里没有 SDL2，因为 SDL2 是一个子代码仓库的连接（使用 git submodel 命令才能下载下来）  

所有例子在 %OgreRoot%/Samples/2.0 目录下面( 虽然目录名是 "2.0", 但却是 “2.1” 的例子 )  

### 编译例子时发生错误，和 "SampleBrowser" 有关
SampleBrowser 是 1.x 的例子，不是 2.X 的例子，请参考上一个章节。  

### 2.1 与 1.x 有多大区别？有哪些期待的变化？
大部分的变更已经涵盖在手册里面了，不过下面是一个快速总结：  

* 原有的内容放到了 v1 命名空间中，如果发现编译错误你只需要增加 "v1"，例如 Entity * myEntity 修改为 v1::Entity *myEntity;  
* Item 取代了 Entity ，因为她更快也更容易使用，不过并不支持 Entity 的全部内容（例如：支持面部表情的姿势动画），对于移植来说 Entity 仍然是有用的。  
* 有了新的材质系统 HLMS(High Level Material System)  
* 原有的材质系统不推荐使用，除非很少的实体使用（因为缓慢而笨拙）或者需要进行后处理（这是它们最有用的地方）  
* 纹理最大程度的保持兼容  
* HlmsTextureManager 管理了 HLMS 的纹理，但是不要被他欺骗了，它只是巧妙的通过 TextureManager 进行纹理管理（为了提升 HLMS 的渲染速度），如非必要你可以不用管他。  
* 新版本中通过合成器进行渲染，它不再是进行后处理的可选组件，而是 Ogre 渲染场景整个工作流中的一部分。  
* 默认的 ParticleFX 仍然可以正常工作  
* 数学类 (Vector3, Matrix4, Quaternion) 最大程度保持相同

### 我如何开始编写 Ogre 应用程序？

### 我对 Ogre 2.1 的线程支持赶到困惑
对于线程支持有老的代码也有新的代码

原来的线程代码可以使用，它需要第三方依赖项（BOOST，POCO，TBB 等），是用来支持后台加载，在我看来这是一个很差的功能因此我不推荐使用它，之所以保留下来是因为一些用户比较成功的使用了它们（虽然不是我们期望的方式）。  
新的线程代码总是启用的，因为直接使用系统的同步原语，不需要在 CMake 总切换任何选项，这些代码用来并行更新场景图、AABB 计算、视锥体裁剪、LOD 选取、灯光裁剪和新版本的骨骼动画。
你可以通过 Root::createSceneManager( ) 告诉 Ogre 创建多少个线程（至少要有一个线程）工作线程是针对 SceneManager 的，如果创建了 2 个含 4 个线程的 SceneManager，Ogre 将创建 8 个线程，值得注意的是，在同一时刻有四个线程在工作，另外四个线程处于休眠状态，因为更新 SceneManager 仍然是串行的。

### 我需要 Boost 库吗？
不需要
除非你要用老的线程功能，否则完全不需要，可以参考上一节

### 有好几个 "2.1" 分支，我应该选那个？
有两个稳定的分支: 2.1 和 2.1-pso 
2.1-pso 分支增加了 "Pipeline State Object" 模型，这是为了支持 Metal、DX12 和 Vulkan，同时也提升了性能和代码可阅读性。另外还增加了对 Compute Shaders 的支持。

该分支还没有合并到 2.1 分支中有两个原因：

* 一些社区提供的第三方库(CEGUI, Gorilla) 无法工作因为他们不能绑定着色器, 我们还没有提供一个工具使这个过程变得容易。
2.1-pso 不像 2.1 在实际的工作中被详细彻底的测试。
  
任何其他 2.1 开头的分支都是不稳定的，并且不要使用

### 支持 Android 吗？
参见 支持 GLES 吗？

### 支持 GLES 吗？
计划修复当前无法使用的 GLES2 渲染系统, 将支持 GLES2 和 GLES3. 支持 GLES2 是因为兼容性，虽然其 API 设计是过时的但考虑到要兼容上百万的安卓设备，所以重点是兼容性和稳定性而不是高性能 (仍然要比 Ogre 1.x 快很多)。或许还有一些我们无法预测的局限性。 
至于 GLES3, 它应该更容易运行高性能的移动应用。

### 支持 WebGL 吗？
一旦 GLES2 就绪，WebGL 的支持就是小菜一碟了，因为它们 99% 是相同的。

### 支持 D3D9 吗？
目前没有支持 D3D9 的计划，或许有人会重写从而支持它，我们将为 Ogre 2.1 实现 GLES2 , 再说了很多团队都不高兴使用 D3D9 了，只有 Assaf 依然关注和维护它. 
只要 GLES2 还没有准备好，我们将保留 D3D9 的代码, 尽管不能保证可用性和稳定性甚至可以编译通过。

### 支持 D3D11 Level 9.x 吗？
It's not a priority. Again, it may get easier to support it using the same paths we'll write for GLES2. But D3D11 level 9.x is a special snowflake very hard to deal with: It imposes weird restrictions HW didn't have, it doesn't map well to GLES2 nor D3D9. Things would've been much easier if level 9.2 == Shader Model 2.x, level 9.3 == Shader Model 3.0, but unfortunately they mixed things and got the worst of all worlds. 
The hope really is that by the time we reach this point, level 9.x hardware support would become irrelevant.

### 支持 iOS 吗？
---
For older iOS devices, support is tied to GLES rendersystem. For newer iOS devices, we're currently working on a Metal RenderSystem.

### 支持 OS X 吗？
---
Once the Metal RenderSystem is ready, OS X should in theory be supported as well. For older Macs that do not support Metal, Ogre supporting GLES3 is their last hope. We do not know how well that will work until that's done.

### 支持 Vulkan/D3D12 吗？
These APIs are in our plans. In fact we are moving to a PSO (Pipeline State Object) approach and our Compositor already knows about tracking Texture/RenderTarget/UAV dependencies and their resource transitions, which should ease greatly porting to these APIs.

However, they're not in the short term goal. Except for Async Shaders, most of these new APIs benefits reduce CPU overhead, not GPU. However, Ogre 2.1 is vastly GPU-bound. 
Vulkan has greater priority than D3D12 because there is little D3D12 can do that D3D11 can't, and because Vulkan is the only way to target high performance graphics in Android (a void no version of GLES is filling). But still not a huge deal because Vulkan capable Android devices are very rare. Even in 2016 there are still devices being manufactured and sold that can only handle GLES2 and KitKat. 
Short term, we're aiming at focusing in our D3D11 and OpenGL paths and extending towards mobile support (GLES & Metal). Our design decisions leverage Vulkan and D3D12 for easy adaption when that happens. But it will be some time until that happens.

### 我创建了多个 RenderWindows and I'm having severe graphical glitches or I get many GL_INVALID_OPERATION errors

### 如何使用 Double 精度？ 编译时有错误
We're not yet officially maintaining double precision, but it works (mostly?). Before you continue, it's very likely the problem you want to solve doesn't need double precision at all, and you just need to learn how to use Camera-relative rendering / Relative Origin(external link) via SceneManager::setRelativeOrigin. A matter of precision(external link) by Tom Forsyth and Don't store that in a float(external link) by Bruce Dawson are very good reads as well.

But if you insist or you really need double precision floats. Here's how:

Enable OGRE_CONFIG_DOUBLE
Disable OGRE_SIMD_NEON
Disable OGRE_SIMD_SSE2

### NEON 支持在 Android 设备上是可选的，但 Ogre 是在编译时选择是否支持 NEON，我如何在运行时动态选择？
Ogre cannot switch between these implementations at runtime. This is on purpose. Supporting runtime switching would require either conditionals everywhere, or function pointers (or something similar, like virtual functions). The overhead from this would completely negate the benefits of using SIMD in the first place. Runtime switching is only useful when the amount of SIMD work is very large, and the number of times function pointers would be called is low (for example video codecs). 

On Desktop the recommended approach to tackle this problem is via two builds and a third build that detects SSE2 support and then launches the correct exe. You can do the same on Android.

In Android you don't build a process. You build a library and a Java process. The Java process loads the library and then executes an entry point defined in the library. This process is not automatic. Your Java code first must load the library with your NDK code. Somewhere in your Java code there must be a snippet similar to this one:

    System.loadLibrary("hello-jni");

Before you load your main NDK library, you would select, in Java, which build to load:

    if( supportsNeon )
        System.loadLibrary("hello-jni-neon");
    else
        System.loadLibrary("hello-jni");

Of course it adds some hassle into your build system since now you need to build your code twice (including Ogre) and your binary size (excluding assets) would double, but this is basically the same hassle desktop applications face. Of course to speed up iteration times, only build one of them for your device and build both versions when you need to deploy.

### 编译 RTSS（Run Time Shader System）时发生错误
RTSS 在 2.1 中已经被废弃， HLMS(高级材质系统)替换了 RTSS 并成为 OGRE 的一部分，它更快、更稳定也更容易使用。

### Is it essential to have at least one HLMS C++ implementation in your project (e.g. OgreHlmsPbs, OgreHlmsPbsMobile, OgreHlmsUnlit, OgreHlmsUnlitMobile) if you're going to render something that is visible on the screen (like a Cube)?
To get PBS materials working you need to:

Link or include in your project the C++ source code of OgreHlmsPbs.
Have the template files under the folders "Samples/Media/Hlms/Common Samples/Media/Hlms/Pbs" bundled with your project for PBS. When you instantiate the HlmsPbs class you have to explicitly tell it the location of these files (see the samples). Important: Don't put the Common and Pbs template files in the same folder.
  
To get Unlit materials working you need to:

Link or include in your project the C++ source code of OgreHlmsUnlit to get Unlit materials.
Have the template files under the folders "Samples/Media/Hlms/Common Samples/Media/Hlms/Unlit" bundled with your project for Unlit. When you instantiate the HlmsUnlit class you have to explicitly tell it the location of these files (see the samples). Important: Don't put the Common and Unlit template files in the same folder.
  
You could write your own Hlms implementations but we provide our own for you that work out of the box. 
At the time of writing the PbsMobile and UnlitMobile projects are not currently 100% working and were intended for GLES2 only.

### 我添加了一个 Point/Spot 光源，但是它不起作用
首先确认使用了 PBS 材质，Unlit 材质对光照无明显反应
其次 point 或 spot 灯光不投下阴影, PBS 默认不会使用它，因此需要使用更高级的技术来处理。你可以开启 Forward3D 来使它正常工作，建议看看 Forward3D 例子的代码。

### 我创建了一个 PBS 自定义几何体，但是它看起来是黑白的
请确认材质是有效的  
请确认 MESH 有法线并且法线正确，如果没有法线使用 PBS 将导致无法进行光照处理  
 
### 我如何编程生产一个 Mesh
如果是 v1 对象，和之前一样。  
如果是 v2 对象，参考 DynamicGeometry 和 CustomRenderable 例子。  